## Task1 - install the Module3 RPM

Coming in Flatrock there will be a TMUI method to install RPMs. Let's activate this feature in 13.1 using the  Postman requests in the "Task1" folder for this module.

Give TMUI a minute to allow the configuration utility to become responsive and then log in. Browse to iApps -> Package Management LX. Here you'll find a simple GUI for installing and removing RPM packages.

Install the "Module3-0.1-001.noarch.rpm" package from the /TechDay2018/LabFiles/Module3 directory of the repo. This will install all the workers needed for this module. All workers included in this RPM can be found in the ```src``` folder of the Module3 folder. Open them in your text editor to follow along with the code samples in the guide.



## Task 2 - HelloBigip Example

This is an example of how to call the local BIG-IP from an iControlLX worker (ie. the BIG-IP where the worker is running).

Example Usage:

```bash
    
    $ curl -k -u user:pass https://[bigip]/mgmt/Nodes
    # returns all the ltm nodes

    $ curl -k -u user:pass http://[bigip]/mgmt/Nodes -d '{ "start": "192.168.1.0", "end": "192.168.1.10" }' -H 'Content-Type: application/json'

    $ curl -k -u user:pass https://[bigip]/mgmt/Nodes
    # returns all nodes including new ones
```


Take note of the utility functions declared that are used to send the HTTP requests.

```javascript
    /**
     * Create a node on this device
     *
     * @param {Object} node
     * @param {RestOperation} originalRestOp
     * @returns {Promise}
     */
    createNode(node, originalRestOp) {
        const nodeUrl = this.restHelper.makeRestjavadUri('tm/ltm/node');

        const restOp = this.restOperationFactory.createRestOperationInstance()
            .setUri(nodeUrl)
            .setBody(node)
            .setIsSetBasicAuthHeader(true)
            .setBasicAuthorization(originalRestOp.getBasicAuthorization());

        return this.restRequestSender.sendPost(restOp);
    }


    /**
     * Get all ltm nodes
     *
     * @param {RestOperation} originalRestOp
     * @returns {Promise}
     */
    getNodes(originalRestOp) {
        const nodeUrl = this.restHelper.makeRestjavadUri('tm/ltm/node');

        const restOp = this.restOperationFactory.createRestOperationInstance()
            .setUri(nodeUrl)
            .setIsSetBasicAuthHeader(true)
            .setBasicAuthorization(originalRestOp.getBasicAuthorization());

        return this.restRequestSender.sendGet(restOp);
    }
}
```

#### restRequestSender

 ```sendGet()``` and ```sendPost()``` are methods of the restRequestSender class. All methods associated with restRequestSender return promises.
 
Look over the restRequestSender [docs](https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-13_1/icontrollx_nodejs_sdk_appendix/module_restrequestsender.html#) to familiarize yourself with this module.


#### restHelper
The destination URI of the resulting request is built with the makeRestjavaUri() method of restHelper(```const nodeUrl = this.restHelper.makeRestjavadUri('tm/ltm/node');```.  This class includes constants and helper methods relating to REST operations and URI. 

Look at the [docs(https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-13_1/icontrollx_nodejs_sdk_appendix/module_resthelper.html?highlight=resthelper#) for this class -- specifically the ```makeRestjavadUri``` method used here.

```javascript
const NODE_URI = '/mgmt/tm/ltm/node';
uri = this.restHelper.makeRestjavadUri(NODE_URI + '/' + "1");
logger.info("makeRestjavadUri:"+uri);
// expect makeRestjavadUri:http://localhost:8100/mgmt/tm/ltm/node/1
```

#### restOperationFactory
This class *creates* a RestOperation that can be used for chained operation. {RestOperation} instances can be generated by this method, or reused from the incoming request, but a restOperation is required to make outgoing HTTP request.

#### restOperation
Note how after the restOperation is created (```restOperationFactory.createRestOperationInstance()```), various ```.set*``` methods are used on the object. The restOperation [docs](https://clouddocs.f5.com/products/iapp/iapp-lx/tmos-13_1/icontrollx_nodejs_sdk_appendix/restoperation.html?highlight=setissetbasicauthheader#) outline these methods.



## Task3 - HelloPlanet Example

We'll use these workers to demonstrate how one worker might interact with another. Recall the behavior with the memoryworker.js example in the previous lab when restarting the ```restnoded``` process. What are some of the normal operational tasks that might restart restnoded?

Usage example:

```bash
    $ curl -k -u user:pass https://[bigip]/mgmt/Hello
    # returns "Hello Earth"

    $ curl -k -u user:pass http://[bigip]/mgmt/Planet
    # returns { "planet": "Earth" }

    $ curl -k -u user:pass http://[bigip]/mgmt/Planet -d '{ "planet": "Mars" }' -X PATCH

    $ curl -k -u user:pass https://[bigip]/mgmt/Hello
    # returns "Hello Mars"
 ```

The 'PlanetWorker.js' is conceptually similiar to the memory worker. You can POST to the endpoint to update its value. 'HelloPlanetWorker.js' simply calls the 'PlanetWorker' URI and concatenates that response with the string "Hello". 

* Run through the "Task3" requests. 
* Note the POST payload of the "Set a Planet" request and the response to the "Hello Worker (again)" request
* Restart the ```restnoded``` process on the BIG-IP.
    * Use the previous request from Module2 or

    ```bash 
    $ bigstart restart restnoded 
    ```
    
* What is the value of "planet" now? 

There are a few unique traits of this worker.

```javascript
class PlanetWorker {
    constructor() {
        this.WORKER_URI_PATH = '/Planet';
        this.isPersisted = true;
        this.isPublic = true;
        this.isStateRequiredOnStart = true;
    }

    onStartCompleted(success, error, state, errMsg) {
        this.state = state;
        success();
    }
    ...
```

The worker requires the state to be loaded *during* the startup proces(```isStateRequiredOnStart```). State is stored in another worker (/shared/storage) with unique keys for each worker. State is updated whenever the ```completeRestOperation``` method is called.

The ```state``` can be retrieved from the ```onStartCompleted``` event. So we simply update ```this.``` restWorker's state with the one just retrieved from storage.

Functionally, this worker follows the same conventions as the memoryworker.js.

* Look at the HelloPlanetWorker.js in your text editor.

We talked about how ```sendGet``` is a method of ```restRequestSender``` that returns a promise and how ```completeRestOperation``` concludes an event. In this worker, we've wrapped some helper functions around methods to make them easier to use.

```javascript
   /// Helper Functions ///

    /**
     * Helper function to set body, content type
     * and resolve operation
     * @param {Object} restOperation
     * @param {String} body
     */
    completeOperation(restOperation, body) {
        restOperation.setContentType("text/plain");
        restOperation.setBody(body);
        this.completeRestOperation(restOperation);
    }

    /**
     * Make a basic REST Op. The URI identifies the path/host/port. The method is a
     * camelcase HTTP verb (i.e. Post, Get, Put, ...). The basicAuth is used for authentication
     * details on the call.
     * @param {String} fullUrl - url path for rest query
     * @return {Promise} promise with output from REST operation
     */
    sendGet(fullUrl ,basicAuth) {
        var restOp = this.restOperationFactory.createRestOperationInstance()
            .setUri(this.restHelper.makeRestnodedUri(fullUrl))
            .setIsSetBasicAuthHeader(!!basicAuth)
            .setBasicAuthorization(basicAuth);
        return this.restRequestSender.sendGet(restOp);
    }
```

The worker then uses the helper functions in the HTTP events.

```javascript
   /**
     * handle onGet HTTP request
     * @param {Object} restOperation
     */
    onGet(restOperation) {
        //HTTP get to dependency planet worker
        this.sendGet(planetUrlPath, restOperation.getBasicAuthorization())
        .then((response) => {
            this.completeOperation(restOperation, this.sayHello(response.getBody().planet));
        }, (err) => {
            this.logger.error(err);
            this.completeOperation(restOperation, this.sayHello());
        });
    }
```

Recall that ```sendGet()``` returns a promise. So the worker calls the PlanetWorker and uses the ```.then()``` method on the promise to pass the response on the ```completeOperation``` helper function. This helper simply sets the content type header and the body on the restOperation and then passes it to ```completeRestOperation```.  

This is a simple example, but if you needeed to make many HTTP calls that required similiar formatting then the use of a helper function will save many lines of code.

